[toc]
## 简介 ##
> 职责链模式(Chain of Responsibility Pattern)：避免将一个请求的发送者与接受者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着链传播请求，直到有一个对象能够处理为止。

- 解耦请求的发送者和处理者，职责链可以使直线、环、树。
- 职责链模式不负责创建职责链，创建工作由其他部分，如客户端完成。

## 结构和实现 ##
- 角色包括：
    - **抽象处理者**：定义处理请求的接口，包含对下一处理者的引用、抽象处理方法。
    - **具体处理者**：实现处理请求的方法。
- 职责链模式结构。<br>![180511.chain.png](https://img-blog.csdn.net/20180511141457963)
- 客户端创建职责链之后，从链的第一个结点开始处理请求。

## 实例 ##
- 企业供应链系统中，采购审批根据金额的不同由不同层次的人审批。<br>![180511.purchase.png](https://img-blog.csdn.net/20180511141616827)

## 纯与不纯的职责链模式 ##
- 纯的职责链:
    - 一个具体处理者对象要么承担**全部责任**，要么将所有的责任推给下家。
    - 一个请求**必须被某一个处理者对象处理**，不能出现未被任何处理者处理的情况。
- 不纯的职责链：
    - 一个请求可以被处理者部分处理之后在向下传递，或者在被处理完之后后续处理者接着处理。
    - 一个请求可以不被任何处理者接收。

## 优缺点和使用环境 ##
- 优点：
    - **解耦请求发送者和处理者**。无需知道具体哪一个对象处理请求，也无需知道职责链的结构，降低系统耦合度。
    - **简化对象的连接**。处理对象只需要指向一个后继者的引用。
    - **增加处理者无需修改源码**。职责链的创建由客户端完成，可以修改链的结构，而不修改源码，符合开闭原则。
- 缺点：
    - **请求可能不被处理**。如果职责链配置不正确，可能到最后一个处理者也无法处理。
    - **职责链涉及对象多**。处理请求可能涉及多个对象，影响性能，调试不便。
    - **可能循环调用**。可陷入死循环。
- 适用环境：
    - 有多个对象可处理请求，需要运行时确定，最终也无需关心具体哪一个处理，只看结果。
    - 需要动态的改变处理者对象的先后逻辑次序。

## jdk中的应用 ##
- ClassLoader加载类，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
- [java类加载机制](https://blog.csdn.net/qq_40369829/article/details/78476412#类的加载机制和双亲委派机制)。