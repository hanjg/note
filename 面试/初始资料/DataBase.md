## 1. SQL操作的类型 ##
包括数据定义、数据操纵(Data Manipulation),数据控制(Data Control)

- 数据定义（DDL，Data Definition Language）：Create Table,Alter Table,Drop Table, Craete/Drop Index等
- 数据操纵（DML）：Select ,insert,update,delete
- 数据控制：grant,revoke

## 2. SQL常用命令： ##
- CREATE TABLE Student( 
ID NUMBER PRIMARY KEY,
NAME VARCHAR2(50) NOT NULL);//建表
- CREATE VIEW view_name AS
Select * FROM Table_name;//建视图
- Create UNIQUE INDEX index_name ON TableName(col_name);//建索引
- INSERT INTO tablename {column1,column2,…} values(exp1,exp2,…);//插入
- INSERT INTO Viewname {column1,column2,…} values(exp1,exp2,…);//插入视图实际影响表
- UPDATE tablename SET name=’zang 3’ condition;//更新数据
- DELETE FROM Tablename WHERE condition;//删除
- GRANT (Select,delete,…) ON (对象) TO USER_NAME [WITH GRANT OPTION];//授权
- REVOKE (权限表) ON(对象) FROM USER_NAME [WITH REVOKE OPTION] //撤权

## 3. 视图 ##
1. 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。
2. 数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。
3. WITH check OPTION 表示对视图进行UPDATE、INSERT、delete操作时要保证更新、删除、或插入的行满足视图定义中的谓词条件 

		Create view IS_Student
		AS
		select Sno,Sname,Sage
		from Student
		where Sdept='IS'
		with check option;
		// 在上述视图上加了with check option子句，以后对该视图进行插入、修改和删除操作时，RDBMS都会自动加上Sdept='IS'

4. **更新视图**：由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。
5. 如果视图定义中有如下子句则不能更新
- 集合操作符（UNION,UNIONALL,MINUS,INTERSECT）
- 聚集函数（SUM,AVG等）
- GROUP BY,CONNECT BY 或START WITH字句
- 由表达式定义的列
- 伪列ROWNUM
- DISTINCT
- （部分）连接操作
### 优点 ###
1. **视图能简化用户操作**：视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。
2. **视图能够对机密数据提供安全保护**：对不同的用户定义不同的视图
3. **对重构数据库提供了一定程度上的逻辑独立性**：视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。 

		例如：将学生关系Student（Sno，Sname，Ssex，Sage，Sdept），
		
		分为SX（Sno，Sname，Sage）和SY（Sno，Ssex，Sdept）两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student：
		
		CREATE VIEW Student（Sno，Sname，Ssex，Sage，Sdept）
		AS
		SELECT SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.Sdept
		FROM SX，SY
		WHERE SX.Sno=SY.Sno；
		
		这样尽管数据库的逻辑结构改变了（变为SX和SY两个表了），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。
### 缺点 ###

- 性能：SQL Server必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。

- 修改限制：当用户试图修改视图的某些行时，SQL Server必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。

## 4. 完整性约束 ##
- 域（列）完整性：属性值应是域中的值，保证数据库字段取值的合理性
- 实体（行）完整性：指关系的主关键字不能重复也不能取“空值"。
- 参照完整性约束：指关系中的外键必须是另一个关系的主键有效值，或者是NULL
- 用户定义完整性：实体完整性和参照完整性适用于任何关系型数据库系统，它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。用户定义完整性(user defined integrity)则是根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件。用户定义完整性主要包括字段有效性约束和记录有效性。例如某个属性必须取唯一值，某个非主属性也不能取空值，某个属性的取值范围在0-100之间等

## 5. 三大范式 ##
## 6. ER模型 ##
- 实体：矩形框
- 属性：椭圆
- 联系：菱形框

## 7. 索引 ##
- 索引是对数据库表中一或多个列的值进行排序的结构，是帮助数据库高效获取数据的数据结构
- 索引类型（Oracle）
	- B-树索引：按平衡树结构组织的索引，Oracle默认建立B-tree索引。适合索引取值范围广，重复率低的应用
	- 位图索引：适用索引值取值范围小，重复率高的应用
	- 函数索引：

			SQL>CREATE INDEX emp_fname_indx ON emp(UPPER(first_name)) TABLESPACE index

	- 唯一性索引与非唯一性索引：普通索引允许被索引的数据列包含重复的值。唯一性索引一是简化了mysql对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。
	- 单列索引与复合索引：INDEX(A, B, C)可以当做A或(A, B)的索引来使用，但不能当做B、C或(B, C)的索引来使用。 

### 优缺点 ###
- 索引加快数据库的检索速度
- 索引降低了插入、删除、修改等维护任务的速度
- 唯一索引可以确保每一行数据的唯一性
- 索引需要占物理和数据空间 

## 8. 事务 ##
定义：事务是一些数据库操作的集合，这些操作由一组相关的SQL语句组成（只能是DML语句），它们是一个有机的整体，要么全部成功执行，要么全部不执行。事务是**数据库并发控制和恢复技术**的基本单位。

- Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
- Consistency（一致性）：数据库一致性（Database Consistency）是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。[https://www.zhihu.com/question/31346392/answer/51924208](https://www.zhihu.com/question/31346392/answer/51924208)
- Isolation（隔离性）：数据库中一个事务的执行不受其他事务的干扰，每个事务都感觉不到还有其他事务在并发执行。
- Durability（持久性）：一个事务一旦提交，则对数据库中数据的改变是永久性的，以后的操作或者故障不会对事务的操作结果产生任何影响。

		BEGIN TRANSACTION 
		COMMIT 
		ROLLBACK
- 关于savepoint
用户在事务（transaction）内可以声明（declare）被称为保存点（savepoint）的标记。保存点将一个大事务划分为较小的片断。之后用户在对事务进行回滚操作（rolling back）时，就可以选择从当前执行位置回滚到事务内的任意一个保存点。当事务（transaction）被回滚（rollback）到某个保存点（savepoint）后，Oracle将释放由被回滚语句使用的锁。

## 9. 锁 ##
1. 悲观锁：每次拿数据的时候都认为别的线程会修改数据，所以在每次拿的时候都会给数据上锁。上锁之后，当别的线程想要拿数据时，就会阻塞，直到给数据上锁的线程将事务提交或者回滚。传统的关系型数据库里就用到了很多这种锁机制，比如行锁，表锁，共享锁，排他锁等，都是在做操作之前先上锁。（利用数据库本身的锁机制实现） 

	- 行锁：
	- 表锁：
	- 页锁：行锁锁指定行，表锁锁整张表，页锁是折中实现，即一次锁定相邻的一组记录。
	- 共享锁又称为读锁，一个线程给数据加上共享锁后，其他线程只能读数据，不能修改。
	- 排他锁又称为写锁，和共享锁的区别在于，其他线程既不能读也不能修改。 

2. 乐观锁：它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。
	- 对记录加版本号.
	- 对记录加时间戳.
	- 对将要更新的数据进行提前读取、事后对比。

## 10. 一次性锁和两阶段锁 ##
### 可串行性 ###
定义：当且仅当某组并发事务的交叉调度产生的结果和这些事务的某一串行调度的结果相同，则称这个交叉调度是可串行化。
可串行化是并行事务正确性的准则，一个交叉调度，当且仅当它是可串行化的，它才是正确的。两段锁协议是保证并行事务可串行化的方法。

- 一次性锁协议，事务开始时，即一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。
- 两阶段锁协议，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。

## 11. 存储过程 ##
- 存储过程（Stored Procedure）：一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。**存储过程不需要返回值**，函数用于返回特定的数据。由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的SQL语句块要快。同时由于在调用时只需用提供存储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网络负担。
### 优点 ###
- 存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应用程序源代码却毫无影响，从而极大的提高了程序的可移植性。
- 存储过程能够实现较快的执行速度：如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程要比批处理的执行速度快得多。因为存储过程是预编译的，在首次运行一个存储过程时，查询优化器对其进行分析、优化，并给出最终被存在系统表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所以速度就要慢一些。
- 存储过程减轻网络流量：对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了网络负载。
- 存储过程可被作为一种安全机制来充分利用：系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。
### 缺点 ###
- 涉及逻辑变更，修改存储过程没有SQL灵活

## 12. 触发器 ##
- 根据触发器作用的对象不同，触发器分为DML触发器、INSTEAD OF触发器和系统触发器三类。
	- DML触发器是建立在基本表上的触发器，响应基本表的INSERT、UPDATE、DELETE操作
	- INSTEAD OF 触发器是建立在视图上的触发器，响应视图上的INSERT、UPDATE、DELETE操作
	- 系统触发器是建立在系统或模式上的触发器，响应系统时间和DDL(CREATE、ALTER、DROP)操作
	- 触发级别：用于指定触发器响应触发事件的方式。默认为语句级触发器，即触发事件发生后，触发器只执行一次。如果指定为FOR EACH ROW，即为行级触发器，则触发事件每作用于一个记录，触发器就会执行一次。
### 优点 ###
- 修改其它数据表里的数据
- 完成比约束更复杂的数据约束：触发器可以实现比约束更为复杂的数据约束 
- 检查所做的 SQL 是否允许
-  返回自定义的错误信息
-  更改原本要操作的 SQL 语句
-  防止数据表构结更改或数据表被删除

### 缺点 ###
- 一个大型应用里，触发器越少越好，触发器会使编程时源码的结构被迫打乱，为将来的程序修改、源码阅读带来很大不便

## 13. 内连接、外连接 ##
### 内连接 ###
- 内连接是保证两个表中所有的行都要满足连接条件。首先在第一个表中查找到第一条记录，然后从头开始扫描第二张表，逐一查找满足连接条件的记录，找到后将其与第一个表中的第一个记录拼接，形成结果集中的一个记录。当第二个表被扫描一遍后，再从第一张表中查询第二个记录，然后再从头扫描第二个表，逐一查找满足连接条件的记录...
- 内连接分为等值连接、不等值连接，自身连接
### 外连接 ###
- 在外连接中，某些不满条件的列也会显示出来，也就是说，只限制其中一个表的行，而不限制另一个表的行。分左连接、右连接、全连接三种

## 14. 维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？ ##
- 答：我是这样做的，尽可能使用约束，如check,主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。

## 15、 游标 ##
- 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

## 16、你能向我简要叙述一下SQL Server 2000中使用的一些数据库对象吗? ##
- 表、视图、用户定义的函数，存储过程，触发器

## 17、NULL ##
- NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。假设您的SQL Server数据库里有ANSI_NULLS，当然在默认情况下会有，对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 UNKNOWN值进行比较，并在逻辑上希望获得一个答案。您必须使用IS NULL操作符。

## 18、你可以用什么来确保表格里的字段只接受特定范围里的值? ##
1. Check限制，它在数据库表格里被定义，用来限制输入该列的值。
2. 触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。

## 19、子查询 ##
- 无关子查询和相关子查询：相关子查询和非相关子查询的不同点在于，相关子查询依赖于父查询，父查询和子查询是有联系的，尤其在子查询的where语句中更是如此
- [http://blog.csdn.net/mascf/article/details/50288199](http://blog.csdn.net/mascf/article/details/50288199)

## 20、临时表空间 ##
- 临时表空间主要用途是在数据库进行排序运算[如创建索引、order by及group by、distinct、union/intersect/minus/、sort-merge及join、analyze命令]、管理索引[如创建索引、IMP进行数据导入]、访问视图等操作时提供临时的运算空间，当运算完成之后系统会自动清理。
- 当临时表空间不足时，表现为运算速度异常的慢，并且临时表空间迅速增长到最大空间（扩展的极限），并且一般不会自动清理了。

## 21、简单描述tablespace / segment / extent / block之间的关系 ##

- tablespace: 一个数据库划分为一个或多个逻辑单位，该逻辑单位成为表空间;每一个表空间可能包含一个或多个 Segment;
- Segments: Segment指在tablespace中为特定逻辑存储结构分配的空间。每一个段是由一个或多个extent组成。包括数据段、索引段、回滚段和临时段。
- Extents: 一个 extent 由一系列连续的 Oracle blocks组成.ORACLE为通过extent 来给segment分配空间。
- Data Blocks：Oracle 数据库最小的I/O存储单位，一个data block对应一个或多个分配给data file的操作系统块。
- table创建时,默认创建了一个data segment,每个data segment含有min extents指定的extents数,每个extent据据表空间的存储参数分配一定数量的blocks

## 22、描述tablespace和datafile之间的关系 ##
- 一个tablespace可以有一个或多个datafile,每个datafile只能在一个tablespace内, table中的数据,通过hash算法分布在tablespace中的各个datafile中,tablespace是逻辑上的概念,datafile则在物理上储存了数据库的种种对象。

## 23、事务回滚 ##
- 回滚段用于保存数据修改前的映像
- 一个事务只能使用一个回滚段来存放它的回滚信息，而一个回滚段可以存放多个事务的回滚信息。一般建议：数量多的小回滚段，每四个事务一个回滚段，每个回滚段不要超过十个事务；对于批处理，一般建议，少的大回滚段，每个事务一个回滚段。
- 事务恢复：当事务正在处理的时候，例程失败，回滚段的信息保存在undo表空间中，ORACLE将在下次打开数据库时利用回滚来恢复未提交的数据。

## 24、日志 ##
### 重做日志文件介绍 ###
- 只有当用户对数据库所做的变更操作产生的重做记录全部写入重做日志文件后，Oracle才认为这个事务已经成功提交。
- 每个数据库至少需要两个重做日志文件，采用循环写的方式进行工作。
### 归档日志文件 ###
- 重做日志文档是指将写满了的重做日志文件保存到一个或多个指定的离线位置，这些被保存的历史重做日志文件的集合称为归档日志文件
- 在数据库出现故障时，即使是介质故障，利用数据库备份额、归档日志文件和联机重做日志文件也可以完全恢复数据库

## 25、数据库引擎 ##
### MyIASM ###
- 索引结构：B+树，数据域存储实际数据的地址。
- 适用：读操作多，不需要数据库事务支持。
### Innodb ###
- 索引结构：B+树，数据域存储实际数据。
- 适用：高并发的写操作，支持ACID事务。
- [https://www.2cto.com/database/201503/385669.html](https://www.2cto.com/database/201503/385669.html "https://www.2cto.com/database/201503/385669.html")

## 26、ACID事务 ##
### 原子性（Atomicity） ###
- 事务是一个不可分割的工作单位，这组操作要么全部发生，否则全部不发生。
### 一致性（Consistency） ###
- 在事务开始以前，被操作的数据的完整性处于一致性的状态，事务结束后，被操作的数据的完整性也必须处于一致性状态。
- 拿银行转账来说，一致性要求事务的执行不应改变A、B 两个账户的金额总和。如果没有这种一致性要求，转账过程中就会发生钱无中生有，或者不翼而飞的现象。事务应该把数据库从一个一致性状态转换到另外一个一致性状态。
### 隔离性（Isolation） ###
- 事务隔离性要求系统必须保证事务不受其他并发执行的事务的影响，也即要达到这样一种效果：对于任何一对事务T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前已经结束，要么在 T1 完成之后才开始执行。这样，每个事务都感觉不到系统中有其他事务在并发地执行。
### 持久性（Durability） ###
- 一个事务一旦成功提交，它对数据库的改变必须是永久的，即便是数据库发生故障也应该不回对其产生任何影响。

## B树 ##
- B树：二叉搜索树。
- B-树：多路搜索树，关键字在整个树的节点出现，包括非叶节点。
- B+树：B-树给叶节点增加链表指针，关键字出现在叶节点。
- [http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html](http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html "http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html")

