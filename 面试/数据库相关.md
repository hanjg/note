[toc]
## Statement和PreparedStatement区别 ##
- PreparedStatement是预编译的，适合批处理，也叫JDBC存储过程。
- Statement每次执行sql语句都要编译，适合一次性的存取。
- PreparedStatement安全性更强，可以使传递的参数强制类型转换。

## 悲观锁 与 乐观锁 的比较 ##
### 悲观锁 ###
- 事务访问数据时需要先取得数据的锁（悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中）。
- 悲观锁的实现，往往依靠数据库提供的锁机制。
### 乐观锁 ###
- 假设事务不会冲突，在提交跟新的时候检测，如果冲突则回滚。
- 乐观锁的实现：1.使用版本号；2.使用时间戳。
### 关键点 ###
- 看加锁和事务回滚哪个成本低

## 数据库的三大范式 ##
### 第一范式 ###
- 强调列的原子性。
- 所有字段值都是不可分解的原子值。
### 第二范式 ###
- 强调列的完全依赖性。
- 一是表必须有一个主键。
- 二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分(主要针对联合主键)。
### 第三范式 ###
- 强调列的直接相关性。
- 非主键列必须直接依赖于主键，不能存在间接依赖。
### 参考 ###
[http://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html](http://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html)

## 数据库连接池 ##
- 程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。
- 创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠。
- [http://blog.csdn.net/wenwen091100304/article/details/48035003](http://blog.csdn.net/wenwen091100304/article/details/48035003 "http://blog.csdn.net/wenwen091100304/article/details/48035003")

## 视图 ##
1. [https://blog.csdn.net/qq_40369829/article/details/79018182#%E8%A7%86%E5%9B%BE](https://blog.csdn.net/qq_40369829/article/details/79018182#%E8%A7%86%E5%9B%BE)
4. **更新视图**：由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。
### 如果视图定义中有如下子句则不能更新 ###
- 集合操作符（UNION,UNIONALL,MINUS,INTERSECT）
- 聚集函数（SUM,AVG等）
- GROUP BY,CONNECT BY 或START WITH字句
- 由表达式定义的列
- 伪列ROWNUM
- DISTINCT
- （部分）连接操作

### 优点 ###
1. **视图能简化用户操作**：视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。
2. **视图能够对机密数据提供安全保护**：对不同的用户定义不同的视图
3. **对重构数据库提供了一定程度上的逻辑独立性**：视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。 

		例如：将学生关系Student（Sno，Sname，Ssex，Sage，Sdept），
		
		分为SX（Sno，Sname，Sage）和SY（Sno，Ssex，Sdept）两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student：
		
		CREATE VIEW Student（Sno，Sname，Ssex，Sage，Sdept）
		AS
		SELECT SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.Sdept
		FROM SX，SY
		WHERE SX.Sno=SY.Sno；
		
		这样尽管数据库的逻辑结构改变了（变为SX和SY两个表了），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。
### 缺点 ###

- 性能：SQL Server必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。

- 修改限制：当用户试图修改视图的某些行时，SQL Server必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。


## 完整性约束 ##
- 域（列）完整性：属性值应是域中的值，保证数据库字段取值的合理性
- 实体（行）完整性：指关系的主关键字不能重复也不能取“空值"。
- 参照完整性约束：指关系中的外键必须是另一个关系的主键有效值，或者是NULL
- 用户定义完整性：主要包括字段有效性约束和记录有效性。例如某个属性必须取唯一值，某个非主属性也不能取空值，某个属性的取值范围在0-100之间等
- 实体完整性和参照完整性适用于任何关系型数据库系统，它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。用户定义完整性(user defined integrity)则是根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件。

## 索引 ##
- 索引是对数据库表中一或多个列的值进行排序的结构，是帮助数据库高效获取数据的数据结构。
- Mysql使用B+树。
### 索引类型（Oracle） ###
- 唯一索引：不同行索引值不同。
- 主键索引：为表创建主键将自动创建主键索引。是唯一索引的特殊类型。
- 聚集索引：各行的物理顺序和键值的逻辑顺序（索引顺序）相同，每张表只能有一个。
- 非聚集索引：物理顺序和逻辑顺序不同。

### 优缺点 ###
- 索引加快数据库的检索速度
- 索引降低了插入、删除、修改等维护任务的速度
- 唯一索引可以确保每一行数据的唯一性
- 索引需要占物理和数据空间

### 实现 ###
- [http://blog.csdn.net/kennyrose/article/details/7532032](http://blog.csdn.net/kennyrose/article/details/7532032 "http://blog.csdn.net/kennyrose/article/details/7532032")

### 索引之间的关系 ###
- 是否唯一和是否聚集无关。
- [http://blog.csdn.net/buynider/article/details/6057609](http://blog.csdn.net/buynider/article/details/6057609 "http://blog.csdn.net/buynider/article/details/6057609")

## 存储过程 ##
- 存储过程（Stored Procedure）：一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。**存储过程不需要返回值**，函数用于返回特定的数据。由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的SQL语句块要快。同时由于在调用时只需用提供存储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网络负担。
### 优点 ###
- 存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应用程序源代码却毫无影响，从而极大的提高了程序的可移植性。
- 存储过程能够实现较快的执行速度：如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程要比批处理的执行速度快得多。因为存储过程是预编译的，在首次运行一个存储过程时，查询优化器对其进行分析、优化，并给出最终被存在系统表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所以速度就要慢一些。
- 存储过程减轻网络流量：对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了网络负载。
- 存储过程可被作为一种安全机制来充分利用：系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。
### 缺点 ###
- 涉及逻辑变更，修改存储过程没有SQL灵活


## 日志 ##
### 重做日志文件介绍 ###
- 只有当用户对数据库所做的变更操作产生的重做记录全部写入重做日志文件后，Oracle才认为这个事务已经成功提交。
- 每个数据库至少需要两个重做日志文件，采用循环写的方式进行工作。
### 归档日志文件 ###
- 重做日志文档是指将写满了的重做日志文件保存到一个或多个指定的离线位置，这些被保存的历史重做日志文件的集合称为归档日志文件
- 在数据库出现故障时，即使是介质故障，利用数据库备份额、归档日志文件和联机重做日志文件也可以完全恢复数据库

## Mysql数据库引擎 ##
### MyIASM ###
- 索引结构：B+树，数据域存储实际数据的地址。
- 适用：读操作多，不需要数据库事务支持。
### Innodb ###
- 索引结构：B+树，数据域存储实际数据。
- 适用：高并发的写操作，支持ACID事务。
- [https://www.2cto.com/database/201503/385669.html](https://www.2cto.com/database/201503/385669.html "https://www.2cto.com/database/201503/385669.html")

## 事务 ##
### 定义 ###
- 事务是一些数据库操作的集合，这些操作由一组相关的SQL语句组成（只能是DML语句），它们是一个有机的整体，要么全部成功执行，要么全部不执行。事务是**数据库并发控制和恢复技术**的基本单位。
### 原子性（Atomicity） ###
- 事务是一个不可分割的工作单位，这组操作要么全部发生，否则全部不发生。
### 一致性（Consistency） ###
- 在事务开始以前，被操作的数据的完整性处于一致性的状态，事务结束后，被操作的数据的完整性也必须处于一致性状态。
- 拿银行转账来说，一致性要求事务的执行不应改变A、B 两个账户的金额总和。如果没有这种一致性要求，转账过程中就会发生钱无中生有，或者不翼而飞的现象。事务应该把数据库从一个一致性状态转换到另外一个一致性状态。
### 隔离性（Isolation） ###
- 事务隔离性要求系统必须保证事务不受其他并发执行的事务的影响，也即要达到这样一种效果：对于任何一对事务T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前已经结束，要么在 T1 完成之后才开始执行。这样，每个事务都感觉不到系统中有其他事务在并发地执行。
### 持久性（Durability） ###
- 一个事务一旦成功提交，它对数据库的改变必须是永久的，即便是数据库发生故障也应该不回对其产生任何影响。
### 两阶段事务和三阶段事务 ###
- [传统分布式事务](https://blog.csdn.net/qq_40369829/article/details/104012837)