[toc]
## 锁的分类 ##
- Innodb的锁分为两种：1、轻量级的闩锁（**latch**），保护内存中的数据结构；2、锁（**lock**），保护数据，一般仅在commit或rollback后释放。<br>![190823.latch.png](https://img-blog.csdnimg.cn/20190823114423397.png)
- lock的分类，SS兼容，其余互斥：
  - 共享锁（S Lock），允许事务读一行记录。
  - 排它锁（X Lock），允许事务删除或更新一条记录。
- 意向锁：表级锁，事务希望在更细粒度上加锁。由于Innodb支持的是行级锁，意向锁不会阻塞除**全表扫描**之外的请求。<br>
  - 意向共享锁：事务希望获得某几行的共享锁。
  - 意向排它锁：事务希望获得某几行的排它锁。 <br>![190823.ISIX.png](https://img-blog.csdnimg.cn/20190823120335417.png)

## 读取加锁 ##
### 一致性非锁定读 ###
- 如果读取的行由于update或delete，加X锁，不会等锁释放，而是读行的快照（undo段实现）。[Innodb快照读](https://blog.csdn.net/qq_40369829/article/details/91359489)。

### 一致性锁定读 ###
- 对select语句显示加锁。
  - 对读取的行加**X锁**：select ... for update。
  - 对读取的行加**S锁**：select ... lock in share mode。

### 自增长和锁 ###
- 之前使用自增长计数器，是一种特殊的表锁，完成自增长值插入的sql后生效。
- 5.1.22之后使用轻量级的互斥量自增长机制。
- sequence id不使用数据库自增长，提高插入效率。

### 外键和锁 ###
- 外键列，如果没有显式的加索引，innodb会自动加索引，避免表锁。
- 外键值插入时：需要查询父表的记录，**用一致性锁定读**，加S锁。
- 尽量在业务层保证数据的一致性，减小数据的压力。

## 加锁算法 ##
### Record Lock ###
- 锁单行上的记录。
- RC级别使用。

### Gap Lock ###
- 间隙锁，锁小于记录值不包括记录本身的范围。

### Next-Key Lock ###
- 锁**范围**，**包括记录本身**。以上两个锁的和。
- innodb查询的列是辅助索引上的键值，则会对键值加Next-key lock，并且对下一个键值加Gap Lock。
- RR级别使用，可解决幻读问题。

#### 加锁规则 ####
- 加锁规则可以概括为：两个原则、两个优化和一个bug:
  - 原则1:加锁的基本单位是**索引区间，前开后闭**。
  - 原则2:查找过程中**访问到的对象才会加锁**。
  - 优化1:索引上的**等值**查询，给**唯一索引**加锁的时，next-key lock退化成**行锁**。
  - 优化2:索引上的**等值**查询，给**非唯一索引**加锁时，向右遍历时且**锁区间最后一个值不满足等值条件**的时候，next-key lock退化为**间隙锁**。
  - 1个bug:**唯一索引上的范围查询**会访问到不满足条件的第一个值为止。
- [参考](https://www.cnblogs.com/nedulee/p/11838682.html)。

### 例子 ###
```sql
Table t （
  a int,
  b int,
  primary key(a),
  key(b)
）

```

- 如果查询条件无索引，执行```select * from t where b = 3 for update```，走聚集索引**全表扫描**，所有记录加锁。
- 表中有两条索引，(1,1),(3,1),(5,3),(7,6)这几条记录。
  - b列辅助索引，加next-key lock，索引分为几段加锁区间：(-∞,1],(1,3],(3,6],(6,+∞)。
- 执行 ```select * from t where b = 3 for update```，会对两条**索引分别加锁**。
  - 辅助索引：加Next-key Lock，并对下一个键值加gap lock，锁定辅助索引b的范围(1,3]和(3,6)。
  - 聚集索引：由于查询未使用**覆盖索引**，对a=5聚集索引加Record Lock。
- 执行``` select * from t where b > 2 for update```。
  - 辅助索引：锁住b[2,+∞)。
  - 聚集索引：由于查询未使用**覆盖索引**，加锁的辅助索引值对应的聚集索引都加锁。
- [详细的加锁样例](https://www.cnblogs.com/nedulee/p/11838682.html)。

## 解锁算法 ##
- **事务提交**时释放锁。
  - 事务1 加X锁，未提交之前事务2 在改锁上写操作阻塞。