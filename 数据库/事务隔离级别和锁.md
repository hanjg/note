[toc]
## 4种隔离级别 ##
- 数据库操作中为了有效保证**并发读取数据**的正确性，定义事务隔离级别，共有4级。
- mysql默认 **REPEATABLE_READ** , Oracle默认 **READ_COMMITTED** 。
- 隔离级别逐渐增强，每种都是为了解决 **脏读、不可重复读、幻读** 中的一个问题。

### READ_UNCOMMITTED ###
- 一个事务可以读取另一个**未提交**事务的数据。
- 最低隔离级别，存在**脏读**问题：事务读取另一个事务未提交的数据。

### READ_COMMITTED ###
- 一个事物在另一个事务**提交后**才能读取数据。
- 解决**脏读**问题，存在**不可重复读**问题：一个事务读取另一个事务提交的数据，前后两次查询结果不一样。

### REPEATABLE_READ ###
- 事务开启之后，不允许有update和delete操作（通过数据库锁实现，但允许insert操作）。
- 解决**不可重复读**问题，存在**幻读**问题：同一个事务查询结果一致，但是如果另一个事务insert新数据，则事务可能会发现新的数据，好像之前的数据是幻觉。
> 不可重复读由于update和delete操作<br>
> 幻读由于insert操作

### SERIALIZABLE ###
- 完全锁定数据，事务**串行**执行。
- 解决**幻读**问题。
- 数据库性能较低。

## 读写锁 ##
### 排他锁 ###
- 排他锁又称写锁。
  - 如果事务T对数据加上排他锁后，则**其他事务不能再对数据加任何类型的锁**。
  - 获准排他锁的事务**既能读数据，又能修改数据**。
- 查询语句可以使用排他锁，对查询的数据每一行加上排他锁。
```sql
SELECT ... FOR UPDATE;
```

### 共享锁 ###
- 共享锁又称读锁。实现**读读并发**。
  - 如果事务T对数据加上共享锁后，则**其他事务只能对数据再加共享锁**，不能加排他锁。
  - 获准共享锁的事务**只能读数据**，不能修改数据。
- 查询语句可以使用排他锁，读取同一版本的数据。
```sql
SELECT ... LOCK IN SHARE MODE;
```

## 隔离级别和锁的关系 ##
- 读未提交：任何操作都不加锁。
- 读提交：数据的**修改删除加排他锁**。
- 重复读：数据**读取之后加共享锁**，无法锁住Insert，会幻读。
- 串行：不能通过行锁解决，需事务串行。

## MVCC ##
- 多版本并发控制：基于乐观锁机制。[参考](https://blog.csdn.net/x_i_y_u_e/article/details/50914083)。

## 总结 ##
- 并发控制一般使用锁和数据多版本。
- 提高并发的思路：
	- 普通锁：串行执行。
	- 读写锁：读读并发。
	- 数据多版本：读写并发。

## 参考 ##
- [https://blog.csdn.net/x_i_y_u_e/article/details/50914083](https://blog.csdn.net/x_i_y_u_e/article/details/50914083)
- [http://blog.csdn.net/qq_33290787/article/details/51924963](http://blog.csdn.net/qq_33290787/article/details/51924963)
- [http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)
- [https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ](https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ)
